# Java 6주차

## 개요

상속(Inheritance)은 클래스의 멤버를 다른 클래스에 물려주는 것을 의미합니다. 상속을 통해 클래스를 재사용하여 새로운 클래스를 만드는 것으로 중복되는 코드를 줄일 수 있습니다. 두 클래스가 상속 관계일 때, 상속을 하는 곳을 ‘상위 클래스(부모 클래스)’ 주는 곳을 ‘하위 클래스(자식 클래스, 파생 클래스)’라고 부릅니다.

---

## 자바 상속의 특징

Java는 대표적인 객체 지향 프로그래밍 언어로, 상속을 지원합니다. 

![Untitled](2%20%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%2030a1740f60e44936a2b2ffdaa46973a8/Untitled.png)

Java의 상속은 다음과 같은 특징을 가지고 있습니다.

1. **여러 개의 부모 클래스를 상속할 수 없음. (다중 상속 불가)**

C++와 Python은 다중 상속을 지원하지만, Java는 지원하지 않습니다. 따라서, extends 뒤에는 하나의 부모 클래스만 올 수 있습니다.

1. **private 접근 제한인 멤버를 상속받을 수 없음.**

private 멤버는 자신의 객 내에서만 호출할 수 있으므로, private 타입인 멤버를 상속받을 수 없으며, 추가적으로, 패키지가 다른 두 클래스 또한, default 타입인 경우 상속할 수 없습니다.

### 상속의 단점

하지만, 상속은 단점도 명백히 있어, 사용에 주의가 필요할 때가 있습니다.

---

## 클래스 상속

![WEEK06.Inheritance1/InheritanceBasic.java](2%20%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%2030a1740f60e44936a2b2ffdaa46973a8/Untitled%201.png)

WEEK06.Inheritance1/InheritanceBasic.java

![WEEK06.Inheritance1/Main.java](2%20%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%2030a1740f60e44936a2b2ffdaa46973a8/Untitled%202.png)

WEEK06.Inheritance1/Main.java

위의 코드에서 InheritanceBasic2 클래스는 InheritanceBasic을 상속받고 있습니다. 즉, InheritanceBasic2 객체를 생성하더라도, InheritanceBasic의 멤버를 사용할 수 있다는 뜻이며, this 참조를 통해, 부모 필드를 자신의 필드로 사용할 수 있습니다. InheritanceBasic의 필드는 모두 protected 제어자이기 때문에 자식 클래스는 부모 클래스의 필드값을 호출할 수 있습니다.

---

## 부모 생성자 호출

부모가 없으면, 자식도 없듯 JVM에서 자식 클래스를 생성할 경우 부모 객체가 우선적으로 생성되고, 후에 자식 객체가 생성됩니다. 

![KakaoTalk_20240426_211048468.jpg](2%20%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%2030a1740f60e44936a2b2ffdaa46973a8/KakaoTalk_20240426_211048468.jpg)

자식 클래스에서 부모 클래스의 생성자가 명시적으로 선언되지 않은 경우, 부모 클래스의 기본 생정자를 생성합니다. 컴파일러는 super();를 첫 줄에 추가하는데, 이는 부모의 기본 생성자를 호출합니다. 위의 코드의 경우 부모 클래스에 직접 생성자를 선언하지 않았기 때문에 문제 없이 실행됩니다. 명시적으로 부모 생성자를 호출하고 싶다면 자식 생성자 내에 super 키워드를 사용하여 나타낼 수 있습니다.

(예시 1-2 3-4)

위의 SuperKeyword 클래스는 SuperKeyword2에게 상속을 하고, SuperKeyword3는 SuperKeyword4를 상속합니다. 부모 클래스에 선언된 생성자에 따라 super() 내의 매개값이 달라질 수 있습니다. super 키워드는 반드시 첫 줄에 위치하며, 매개값의 타입과 일치해야 합니다.

---

## 메소드 오버라이딩

부모 클래스의 모든 메소드가 자식 클래스에 맞춰 설계되는 것이 이상적이겠지만, 실제로는 그렇지 않은 경우도 있습니다. 이 경우 상속된 일부 메소드를 자식 클래스에서 다시 수정해서 사용할 수 있는데, 이를 ‘메소드 오버라이딩(Method Overriding)’ 또는 ‘메소드 재정의’라고 합니다.

### 메소드 오버라이딩 방법

메소드 오버라이딩은 다음과 같은 조건을 만족해야할 수 있습니다.

1. **부모의 메소드와 동일한 시그니처(반환값, 메소드명, 매개 변수 목록)을 가져야 함.**
2. **접근 제한을 더 강하게 오버라이딩할 수 없음.**

ex) 부모 메소드가 protected인 경우, 자식 메소드는 더 좁은 범위인 private로 오버라이딩 불가하지만, public 또는 default로 오버라이딩이 가능합니다.

1. **새로운 예외(Exception)를 throws 할 수 없음.**

메소드가 오버라이딩된 경우 부모 객체의 메소드는 숨겨지므로, 자식 객체에서 메소드를 호출하면 오버라이딩된 자식 메소드가 호출됩니다.

(오버라이딩 예시 - 원의 넓이 구하는 것 확장. 3.14 → Math.PI)

위와 같이 *** 메소드가 오버라이딩되어 더 정확한 값을 반환하고 있는 것을 확인할 수 있습니다. @override는 어노테이션(Annotation)으로, 주석(Comment)과 비슷한 역할을 합니다. 어노테이션은 컴파일러에게 문법 에러를 체크하도록, 프로그램 빌드시 코드를 자동으로 생성할 수 있도록, 런타임에 특정 기능을 실행하도록 정보를 제공합니다. 어노테이션은 @를 사용하여 작성하며, 해당 타겟에 대한 동작을 수행하는 프로그램 외에는 다른 프로그램에게 영향을 주지 않습니다.

### 부모 메소드 호출

자식 클래스가 메소드 오버라이딩을 한 경우 기존 부모의 메소드는 숨겨지며, 이를 호출하기 위해서는 super 키워드를 사용하여 부모 메소드를 호출할 수 있습니다.

(super.메소드명 호출 예시)

---

## final 클래스와 final 메소드

final 키워드는 해당 선언이 최종 상태이고 수정될 수 없음을 뜻합니다. 필드에 사용할 경우, 초기값 설정 이후 값을 변경할 수 없어 상수로도 사용됩니다.

### final 클래스

클래스 선언시 final 키워드를 class 앞에 붙이면, 이 클래스는 최종적인 클래스를 의미하게 되어 상속할 수 없는 클래스가 됩니다. 즉, final 클래스는 부모 클래스가 될 수 없어 자식 클래스를 만들 수 없게 됩니다.

### final 메소드

final 메소드는 최종적인 메소드이므로, 자식 클래스가 메소드 오버라이딩을 하지 못하도록 합니다.

---

## 다이나믹 메소드 디스패치

메소드 디스패치(Method Dispatch)는 어떤 메소드를 호출할 것인가를 결정하고 실행하는 과정을 의미합니다. 컴파일 시점에서, 컴파일러가 특정 메소드를 호출할 것을 명확하게 알고 있는 경우를 정적 디스패치(Static Dispatch)라고 합니다.

---

## 클래스의 타입 변환과 다형성

다형성(Polymorphism)이란, 하나의 변수 또는 메소드가 상황에 따라 다른 의미로 해석될 수 있는 것을 의미하고, 객체 지향 프로그래밍의 주요 요소입니다. 이를 통해, 다양한 객체를 이용해 다양한 실행결과를 만들 수 있습니다. 

다형성을 구현하기 위해서는, 메소드 재정의와 타입 변환이 필요합니다.

### 자동 타입 변환

자동 타입 변환(Promotion)은 프로그램 실행 도중에 자동적으로 타입 변환이 발생하는 것을 의미하며, 이는 상속 관계에 있는 클래스 사이에서 발생하기도 합니다.

자동 타입 변환은 자식이 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급될 수 있다는 원리로 작동합니다. 즉, 자식은 부모 타입으로 자동 타입 변환이 가능합니다. 

(person student)

위의 코드에서, Student 클래스는 Person 클래스로부터 상속을 받으므로, 자식 객체로 정의할 수도 있으며 두 변수는 동일한 객체를 참조하게 됩니다. 또한, 부모 객체는 자식 클래스의 생성자를 통해 생성할 수 있습니다. 이는, 자식 클래스의 생성자가 부모 클래스의 생성자를 포함했기 때문입니다. 

다음은 A - B - D, A - C - E로 상속 관계인 클래스입니다.

(예시 - ABCDE)

조건을 만족할 경우 프로모션이 발생합니다. 부모 타입으로 자동 변환된 이후에는 부모 클래스의 멤버만 접근할 수 있게 됩니다. 비록, 자식 객체를 참조하지만, 접근 가능한 멤버는 부모 클래스로 한정됩니다. 그러나, 자식 클래스에서 메소드가 오버라이딩된 경우 자식 클래스의 메소드가 대신 호출됩니다.

(예시 - parent child)

(사진 정리 예시)

### 필드의 다형성

이것만 본다면, 자동 타입 변환의 필요성을 느끼기 어렵습니다. 자식 타입을 처음부터 사용하면 되기 때문입니다. 위와 같은 작업을 하는 이유는 다형성을 구현하기 위해서입니다. 필드의 타입을 부모 타입으로 선언한다면 다양한 자식 객체들이 저장될 수 있어 필드 사용 결과가 달라질 수 있습니다. 자동차의 부품이 더 좋은 것으로 교체되는 것처럼, 객체 지향 프로그래밍에서도 객체들이 다른 객체로 교체될 수도 있어야 합니다.

(다형성 코드 예시 battery machine)

배터리 수명을 다한 배터리를 교체할 때, Apple과 Samsung의 배터리로 교체를 했습니다. 이때, Machine 객체의 필드인 battery1~4에 AppleBattery와 SamsungBattery 객체를 대입하여 자동 타입 변환을 일으키고 있습니다. 객체가 교체된 이후에도 계속 코드는 정상적으로 실행됩니다. 

### 매개변수의 다형성

메소드를 호출할 때, 매개값을 다양화하기 위해 매개 변수에 객체를 지정할 수도 있습니다.

Bus 클래스는 Vehicle로부터 상속을 받고 있고, 매개변수를 Bus로 선언하게 된 경우 자동 타입 변환이 발생합니다. 매개변수의 타입이 클래스일 경우, 해당 클래스의 객체뿐만 아니라 자식 객체의 매개값도 사용할 수 있습니다. 자식 객체가 메소드를 오버라이딩한 경우 메소드의 실행 결과도 마찬가지로 재정의됩니다.

(예시, Vehicle Driver)

### 강제 타입 변환

강제 타입 변환(casting)은 부모 타입을 자식 타입으로 변환하는 것을 의미하며, 변수의 캐스팅과 같이 항상 변환될 수 있는 것은 아닙니다. 객체의 강제 타입 변환은 자식 타입이 부모 타입으로 자동 타입 변환된 후에 다시 자식 타입으로 변환될 때만 사용할 수 있습니다.

즉, 위와 같은 경우에만 강제 타입 변환이 가능해집니다.

(예시)

### 객체 타입 확인

강제 타입 변환은 자식 타입이 부모 타입으로 변환된 상태에서 다시 자식 타입으로 변환할 때만 사용 가능하기에 처음부터 부모 타입으로 생성된 객체는 자식 타입으로 변환할 수없습니다. 코드가 짧다면 크게 문제가 안 될 수 있지만, 코드가 길다면, 이를 찾는 것이 어려울 수도 있습니다. 이때 사용한 것이 instanceof 연산자입니다. 

instanceof 연산자는 좌항에 객체가, 우항에는 타입이 오는데, 좌항의 객체가 우항의 인스턴스(instance)면 true를, 아니면 false를 반환합니다. 다음과 같이 조건을 확인한 후에 강제 타입 변환을 한다면 코드의 오류(ClassCastException)를 줄일 수 있습니다.

(예시)

---

## 추상 클래스

객체를 직접 생성할 수 있는 클래스를 ‘실체 클래스’라고 하고 이 클래스들의 공통적인 특성을 추출해서 선언한 것을 ‘추상(Abstract) 클래스’라고 부릅니다. 예를 들어, CPU.class, GPU.class, RAM.class의 공통적인 특성을 추출하여, Computer.class를 만들 수 있습니다. 이때, Computer.class는 추상 클래스입니다.

### 추상 클래스 용도

추상 클래스를 사용하는 이유는 공통된 필드와 메소드의 이름을 통일하고, 실체 클래스를 작성할 때의 시간을 절약하기 위해 사용됩니다. 

### 추상 클래스 선언

추상 클래스를 선언하는 경우 class 앞에 abstract를 붙여야 합니다. 추상 클래스는 자기 자신의 객체를 new 연산자를 통해 생성할 수 없고 오로지 자식 클래스만 만들 수 있습니다. 그러나, 추상 클래스는 자식 객체가 생성될 때, 부모 클래스의 생성자를 호출하므로, 추상 클래스도 직접 호출할 수는 없지만, 생성자가 필요합니다.

(예시)

### 추상 메소드 오버라이딩

추상 클래스로 공통적인 부분을 잡았다고 하더라도, 자식 클래스가 메소드를 재정의해야하는 상황이 발생할 수도 있습니다. 추상 메소드를 선언한다면 위의 문제를 해결할 수 있씁니다. 추상 메소드는 abstract를 반환 타입 앞에 둬서 선언할 수 있고, 메소드 실행 내용이 없어, 중괄호가 포함되어 있지 않습니다. 추상 클래스 설계시, 자식 클래스가 반드시 실행 내용을 채워야 하는 경우 추상 메소드를 사용하여 자식 클래스가 반드시 메소드를 재정의하게 할 수 있습니다.

(예시)

3가지 호출 방식을 통해, 메소드를 호출했습니다.

---

## Object 클래스

Java에서 클래스가 그 어떤 클래스로부터 상속받지 않을 때, Object 클래스를 기본적으로 상속받게 됩니다. Object는 자바의 최상위 부모 클래스이며, 사용자가 정의한 클래스를 상속받지 않는 클래스도 결국 Object 클래스를 상속받으므로, 모든 클래스는 Object 클래스를 상속받게 됩니다.

Object 클래스는 필드가 존재하지 않고 메소드로만 구성되어 있고, 모든 클래스에서 이용할 수 있다는 특징이 있습니다.

Object 클래스의 대표적인 메소드로는 equals(), hashCode(), toString()이 있습니다. 모든 클래스는 Object 클래스의 자식 클래스이기 때문에, 메소드들은 오버라이딩될 수도 있습니다.

### equals()

Object 클래스에서 equals() 메소드는 ‘public boolean equals(Object obj) { … }’와 같은 형태를 가집니다. 매개변수로 Object를 받으므로 모든 자식 타입이 올 수 있습니다.

equals()는 비교 연산자인 ‘==’와 동일한 결과를 반환합니다. 두 객체가 참조하는 값이 같은 경우 true를, 다를 경우 false를 반환합니다.

하지만, 참조 타입인 String과 같은 변수도 사용할 수 있는데, 이 경우 참조하는 값을 확인하는 것이 아닌 문자열이 동일한지를 조사하여 같으면 true, 아니면 false를 반환하게 합니다. String 클래스가 Object의 equals() 메소드를 오버라이딩했기 때문입니다.

(예시)

### hashCode()

객체 해시코드란, 객체를 식별할 정수값을 의미합니다. hashCode() 메소드는 객체의 메모리 번지를 이용하여 해시코드를 만들어 반환합니다.

### toString()

[https://kephilab.tistory.com/92](https://kephilab.tistory.com/92)
